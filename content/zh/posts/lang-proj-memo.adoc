= 小而完整的语言/VM 项目方法论 + A–F 方向实施备忘（Cheat Sheet）

面向对象

- 想做 TinyCC / QuickJS / LuaJIT 那样“小、独立、完整”的项目
- 正在选择并落地 A–F 方向之一

== 1. 通用方法论与工程纪律

=== A. 心态与基础（mindset & foundation）
- 核心目标只选一件（体积/确定性/嵌入性/标准兼容/吞吐/延迟/安全性）
- 深厚基石：编译原理（词法/语法/语义/IR/优化/后端）、VM 设计（栈机/寄存器机/指令集/闭包/GC）、OS/ABI（调用约定/W^X/内存布局）、C 专家级（指针/未定义行为/跨平台）
- 大量读源：Lua / TCC / QuickJS / LuaJIT；理解“极简而强”的折中

=== B. 先立界，再施工（边界与非目标）
- 体量目标：MVP 7–12k LOC；零/极少依赖；C89/C99，可跨 Windows/Linux/macOS
- 非目标：起步不做 JIT/复杂优化/庞大标准库，不追“所有语法/所有平台”

=== C. MVP 路径（最小闭环 → 渐进增强）
- 词法/语法（手写递归下降）→ AST → 树遍历解释器（先通）
- 升级：字节码 VM（大 `+switch+`）→ 快路径/IC/quickening →（可选）baseline JIT
- 坚持“慢且正确”，每步优化均可回退

=== D. 架构与关键抉择（cheat sheet）
- VM：stack VM（实现小）vs register VM（优化友好；Lua 使用寄存器机）
- 值表示：tagged union 起步 → 性能极限再 NaN-boxing
- GC：mark-sweep 或 RC 起步；低停顿用增量/分代；实时倾向 RC + 周期检测或 `+arena+`
- 解析：手写递归下降可读好调；PEG/packrat 语法友好但注意性能/内存
- 调试：字节码携带文件/行列/常量池 `+idx+`；完整 stack trace
- 可移植：JIT 抽象为后端；解释器永远可用；注意 W^X

=== E. 工程质量（三板斧）
- 差分测试：慢速“模型执行器”vs VM，比对结果/副作用
- Fuzz：语法/运行时/FFI/GC/资源预算；崩溃最小复现自动化
- 度量可视化：指令计数/分配/GC/RC/IC 命中/热点位点/预算消耗

=== F. 通用 12 周里程碑（模板）
1. 解析/AST；树解释器（可选）
2. 字节码 VM + 基本指令 + 闭包/异常/调试信息
3. 值/对象模型 + 内存（GC 或 RC/`+arena+`）+ 字符串驻留
4. 资源/限额（步/内存/时间）+ 错误模型
5. 并发原语（协程/状态机/迭代器）或领域关键能力
6. IC/quickening/常量折叠/尾调用等低风险优化
7. FFI + 最小标准库 + 宿主集成
8. REPL/disasm/profiler 等工具与可视化
9. fuzz/压力/跨平台 CI
10. 文档/示例/基准/验收
11. 预发布回归与性能稳定
12. 发布与反馈收集

=== G. 代码结构与文档（建议）
- `+core/+`（`+lexer+`、`+parser+`、AST、`+codegen+`、VM、`+bytecode+`）
- `+runtime/+`（对象模型、GC/RC/arena、标准库）
- `+embed/+`（C API/FFI/沙箱）
- `+tools/+`（REPL、disasm、profiler、fuzz harness）
- `+tests/+`（语义、性能、GC/RC、FFI、资源、差分）
- `+docs/+`（设计记录、语言规范草案、嵌入指南、示例）

== 2. 方向速查与对比表

|===
| 方向 | 核心诉求 | 典型场景 | 可行性 | 难度 | 差异化 | MVP 体量

| A 确定性/硬实时脚本 VM
| 可预算、可证明停顿上限
| 游戏帧逻辑、机器人、低延迟撮合
| 强
| 中
| 强
| 7–12k LOC

| B 数据处理脚本
| 结构化数据 + pipeline + 惰性
| CLI/ETL、日志/JSON/CSV 处理
| 强
| 中
| 中强
| 8–12k LOC

| C 嵌入式 Datalog
| 声明式规则 + 增量推理
| 权限/策略、配置校验、AI
| 中强
| 中
| 强
| 6–10k LOC

| D 类型化连接式
| 栈效应类型 + HM 推断
| 嵌入/教学/DSL/AOT 到 C/Wasm
| 中
| 中高
| 中强
| 6–9k LOC

| E 代数效应小语言
| effects/handlers 教学可用
| 协程/异步建模、嵌入
| 中
| 中
| 中强
| 4–7k LOC

| F 安全系统级脚本
| 无 GC/确定性内存 + 线性类型
| 实时/嵌入/高可靠插件
| 中强
| 中高
| 强
| 8–12k LOC
|===

TIP: 若追真实需求与快速形成差异化，优先 A；偏工具链与数据工程选 B；偏声明式/形式化选 C；偏范式与类型系统选 D/E；追系统级安全与确定性选 F（或 A+F 融合）。

== 3. 方向 A：确定性/硬实时脚本 VM（强推）

=== A1. 定位与目标
- 承诺：每帧/每 tick 延迟上限可控；时间/内存预算超限可捕获，不产生 STW 卡顿
- 用途：游戏（客户端/服务器）、机器人/控制、低延迟后端

=== A2. 语言/语义约束
- 类 Lua 语法；限制递归深度；显式分配域：`+frame.*+` vs `+persist.*+`
- `+yield+` 不分配；时间与随机需显式注入，保证可复现
- 三类异常：资源（步/内存）、类型/边界、FFI 错配；均携带源位置信息

=== A3. 执行模型/字节码/成本
- stack VM；字节码位点携带文件/行列/常量池 `+idx+`
- 成本表（VM 步示例）：`+LOAD+`/`+CONST+`=1，算术=2，`+CALL+`=5+ 参数数；属性访问 IC 命中=3/未命中=12
- IC + quickening：对热点全局/属性专用化

=== A4. 内存模型（双区）
- frame 区（`+arena+`）：bump-pointer；帧末 O(1) `+reset+`；热对象尽量放这里
- 持久区（RC + 可选周期检测/增量标记）：对象头 `+rc+`、写屏障；优先避免环

=== A5. 协程/调度
- 用户态状态机；`+resume(co, steps)+`；耗尽返回 `+EXHAUSTED+`，异常可捕获
- 宿主按帧调度：`+set_frame()+` 重置 `+arena+` → 轮询协程

=== A6. FFI/嵌入
- C API：`+vm_create+`/`+vm_load+`/`+vm_call+`/`+vm_set_budget+`/`+vm_poll+`；FFI 签名注解内存语义与 worst-case 成本
- I/O 与系统能力仅通过宿主注入（默认沙箱）

=== A7. 标准库/优化/工具
- 标准库：数组/表（frame/persist 构造器）、字符串驻留、数学、时间（注入）
- 优化：常量折叠/尾调用 → IC/quickening → 热点专用化（可选 baseline JIT）
- 工具：REPL、disasm、profiler（预算报告/IC 命中/热点）

=== A8. 12 周里程碑
1. 解析/AST/字节码生成
2. VM + 闭包/异常 + 源级栈
3. `+arena+` + RC + 字符串驻留
4. 预算系统（步/内存）+ 资源异常
5. 协程 + 宿主帧调度
6. IC/quickening + 热点统计
7. FFI + 最小标准库
8. profiler + 预算可视化
9. fuzz/压力/跨平台
10. 文档/示例/基准
11. 回归与性能稳定
12. 发布与集成样例

=== A9. 风险与对策
- GC 暂停/写屏障成本 → 热对象入帧区、持久区增量、减少跨区写
- 隐式分配 → API 标注 + lint/静态检查 + 运行时告警
- 预算标定不准 → 以 VM 步为基准、离线校准、FFI 强制注解

=== A10. 指标/体量
- 启动 < 30ms；空 VM 常驻 < 10MB；无长尾；算术/控制流性能≈Lua 5.x ±30%
- LOC：7–12k

== 4. 方向 B：数据处理脚本语言（data-wrangling）

=== B1. 定位与目标
- 一体化处理 JSON/CSV/YAML/TOML + pipeline + 惰性迭代；介于 jq/awk 与 Python/Pandas 之间
- 启动快、占用小、组合性强，适合 CLI/ETL 与嵌入

=== B2. 语言/语义
- 语法：管道 `+|+`、占位符 `+_+`、路径 `+.a.b[0]+`、模式匹配 `+match+`
- 值：Null/Bool/Int/Float/String/Array/Map/Bytes/DateTime（可迭代）
- 惰性流：`+Iterator<Value>+`，边读边算，避免全量载入

=== B3. 执行/VM/优化
- stack VM；管道编译为算子链；算子融合（map→map、filter 合并），谓词下推到 reader
- 热点路径访问 IC；CSV/JSON 流式解析；外部排序/分块聚合

=== B4. 标准库/FFI
- I/O：`+from_json+` / `+from_csv+`、`+to_json+` / `+to_csv+`、`+read_lines+` / `+write_file+`
- 算子：`+map+`、`+filter+`、`+select+`、`+group+`、`+reduce+`、`+sort+`、`+unique+`、`+join+`（渐进补齐）
- FFI：注册原生数据函数；可桥接外部进程（受限沙箱）

=== B5. 工具/里程碑/指标
- 工具：CLI/REPL、profiler（算子吞吐/丢弃率/耗时）、formatter/linter
- 12 周里程碑
1. 语法/解析（递归下降）+ AST + 基本值类型
2. stack VM + 基础算子（`+map/filter/select/reduce+`）
3. JSON/CSV reader/writer（流式）+ 路径访问器
4. 管道优化（算子融合）+ 错误上下文（文件/行/列/路径）
5. profiler 与统计（算子级吞吐/丢弃率/耗时）
6. C API/FFI + 最小标准库补齐
7. 排序/`+group_by+`（外部内存友好小顶堆/归并）
8. `+regex+`/时间解析等实用函数
9. fuzz（随机 JSON/CSV）+ 差分测试（对标 jq/csvkit）
10. 跨平台打包
11. 文档/示例集完善
12. 发布与反馈
- 指标：启动 < 30ms；JSON 行吞吐 ≥ 200k lines/s；流式常驻 < 10MB
- LOC：8–12k

=== B6. 风险对策
- 大文件内存峰值 → 严格流式 + 外部排序/分块
- 复杂路径性能 → IC + 字段缓存
- 标准库膨胀 → 明确核心 + 插件化

== 5. 方向 C：嵌入式 Datalog/规则引擎

=== C1. 定位与目标
- 小而可嵌入的 Datalog 引擎；声明式规则 + 增量推理
- 场景：权限/策略、配置校验、依赖分析、游戏 AI

=== C2. 语言/执行
- 正 Datalog（可选分层否定）；facts/rules，集合语义
- 半朴素评估（Δ 驱动）直到固定点；按谓词分表、列式存储、索引（主键/二级）

=== C3. 优化/FFI
- 索引建议与简单 join 规划；小规模 hash join/索引嵌套循环
- C API：`+add_fact+` / `+retract_fact+` / `+query+`，`+register_external+`（纯外部谓词）

=== C4. 工具/里程碑/指标
- 工具：可视化（依赖图/层次图）、统计（物化规模/命中率）
- 12 周里程碑
1. 解析 + AST/IR（谓词/项/规则）+ 正 Datalog 安全性检查
2. 关系存储（列式 + 基本索引）+ 去重集合
3. 半朴素评估（Δ 驱动）+ 迭代直至固定点
4. 外部谓词（比较/算术）+ 模式匹配查询接口
5. C API + 批量导入/导出（CSV）
6. 增量更新（EDB 变更影响集）+ 统计
7. 规则规划器（启发式 join 顺序）+ 性能基准
8. 可选分层否定 + 安全性/层次检查
9. fuzz（随机规则/事实）+ 差分（对标 Soufflé/小样本）
10. 文档/案例库（权限策略/配置验证）
11. 包装与跨平台 CI
12. 发布与反馈
- 指标：百万级事实/秒（视规则形态）；内存（字典压缩）可控
- LOC：6–10k

=== C5. 风险对策
- 连接爆炸 → 强制索引/限制 join 宽度/基数驱动顺序
- 去重成本高 → 排序去重 + 分块 + 压缩编码
- 否定复杂 → MVP 先不做或仅做分层否定

== 6. 方向 D：类型化连接式语言（Forth/Joy + HM）

=== D1. 定位与目标
- 连接式范式 + 强类型（栈效应 + HM 推断）；零运行时类型检查；可 AOT 到 C/Wasm

=== D2. 语言/类型
- 词即函数（后缀）；组合子丰富；块 `+[ ... ]+` 作为一等值
- 栈效应类型：`+dup: a -- a a+`，`+add: Int Int -- Int+`
- 多态 + HM：剩余栈变量 `'S`；常用容器/ADT（可选）

=== D3. 编译/执行/优化
- 类型期生成/合并栈效应约束（HM 统一）；到字节码或 AOT C（热点单态化）
- 运行：stack VM，tagged union；优化：词内联/常量/栈折叠

=== D4. FFI/里程碑/指标
- FFI：为词声明栈效应 + C 函数指针
- 12 周里程碑
1. 词法/解析（后缀语法 + 引用块 `+[ ... ]+`）
2. 类型系统（`+'S+` 剩余栈 + HM 统一）+ 友好错误信息
3. stack VM + 基本词实现 + 容器与 RC
4. 标准库（栈/算术/容器/控制组合子）
5. AOT 到 C（基础单态化）+ 运行库雏形
6. FFI（注册外部词）+ 示例集
7. 优化（词内联/常量折叠/栈折叠）
8. 文档与类型推断可视化
9. fuzz（随机词序列 + 类型约束）+ 差分（解释器 vs AOT）
10. 打包/跨平台发布
11. 回归与性能稳定
12. 发布与反馈
- 指标：编译期推断 < 数百 ms；AOT 1.5–3× 解释器
- LOC：6–9k

=== D5. 风险对策
- 类型错误可读性差 → 生成“期望栈 vs 实际栈”可视化
- 多态爆炸 → 仅单态化热点；保留解释路径
- 组合子复杂控制流 → 限制递归，偏迭代组合子

== 7. 方向 E：代数效应小语言（effects/handlers）

=== E1. 定位与目标
- ML 核心 + effects/handlers；单文件/可嵌入；协程/异步建模教学利器

=== E2. 语义/实现
- `+perform Op(args)+` 与 `+handle expr with { case Op(x, k) -> ...; return v -> ... }+`
- 解释器采用 CPS + defunctionalization；one-shot 续延（多次恢复可后加复制）

=== E3. 运行时/优化/FFI
- 值：tagged union；闭包捕获环境
- 优化：闭包分配优化、模式匹配编译、热门 handler 内联
- FFI：注册原生效应与处理器；宿主可控制续延恢复策略

=== E4. 工具/里程碑/指标
- 工具：REPL、续延/处理器栈可视化、效应触发统计
- 12 周里程碑
1. 语法 + 模式匹配 + AST
2. CPS 解释器骨架 + 闭包/环境捕获
3. effects/handlers 语义 + 续延表示（one-shot）
4. 标准库（console/state）+ 错误栈与未处理效应报告
5. FFI（注册效应/处理器）+ 示例
6. 优化（匹配编译/常量折叠）
7. 可视化与调试（续延/处理器栈快照）
8. async 模型（可选）+ 限流策略
9. fuzz（随机模式/效应）+ 行为回归集
10. 文档/单文件打包
11. 回归与性能稳定
12. 发布与反馈
- 指标：效应开销微秒级（解释器）；单文件 4–7k LOC

=== E5. 风险对策
- 续延实现复杂 → 避免 OS 栈操作；纯 CPS/one-shot 起步
- 多次恢复需求 → 复制续延或限制模式
- 性能忧虑 → 小而精 + 内联 handler 足以覆盖教学与嵌入

== 8. 方向 F：安全的系统级脚本（无 GC/确定性内存）

=== F1. 定位与目标
- “脚本灵活 + 内存确定性/安全”；无 STW GC；适用于实时/嵌入/高可靠插件

=== F2. 语言/安全模型
- 默认 move-only（线性类型）；MVP 无借用或仅只读短借用
- 资源类型显式 `+drop+`；`+Result<T, E>+` 与 `+?+` 传播；开发态 `+panic+`

=== F3. 运行时/内存/验证
- RC + `+Cow+`；`+pinned buffer+`（稳定地址）供 FFI 零拷贝
- 字节码验证器：装载期检查 use-after-move/双释放/别名违规

=== F4. FFI/优化/工具
- FFI 签名需注解：`+noalloc+`/`+alloc+`/`+borrowed+`/`+transfer+` 与 worst-case 成本
- 优化：逃逸分析（栈/`+arena+` 分配）、边界检查消除、IC
- 工具：生命周期图、泄漏统计、RC 热点

=== F5. 里程碑/指标/风险
- 12 周里程碑
1. 语法 + 类型（线性/move）设计与解析
2. 寄存器 VM + 值模型（线性资源/普通值）
3. 静态检查（use-after-move）+ 字节码验证器
4. 基础容器（`+Vec+`/`+Map+`，move 语义）+ RC/`+Cow+`
5. FFI（内存语义注解）+ `+pinned buffer+`
6. 文件/网络资源封装（自动 `+drop+`）
7. 逃逸分析（栈/`+arena+` 分配）
8. 优化（边界检查消除）+ 基准
9. fuzz（移动/借用/FFI 混合）+ 崩溃最小化
10. 文档/示例（嵌入式/游戏服/插件）
11. 回归与性能稳定
12. 发布与反馈
- 指标：无 STW；错误多数编译期捕获；延迟抖动可控
- LOC：8–12k
- 风险对策：先不做借用、避免 RC 循环（`+Weak+`/约束）；FFI 强制注解 + 断言

== 9. 统一的交付/质量/验收清单

=== A. 交付物
- 源码（`+core/runtime/embed/tools/tests/docs+`）
- 语言规范草案 + 嵌入/FFI 指南 + 示例集
- 工具：REPL、disasm、profiler、fuzz harness
- 基准：micro（算术/容器/调用）+ macro（场景特定）

=== B. 质量门槛
- 单测覆盖核心语义路径与错误路径
- 差分测试：模型执行器 vs VM（或对标参考实现）
- 模糊测试：语法 + 运行时 + FFI + 资源预算
- 资源/长稳：小时级压力测试；崩溃最小复现自动入回归集
- 安全/可移植：未定义行为/对齐/大小端；W^X（若 JIT）；沙箱默认开启

=== C. 验收指标（按方向补充）
- 启动时延、常驻内存、吞吐/延迟、GC/RC 次数与时长、IC 命中、热点 top-N
- 方向特定：
  * A：无长尾帧；预算可日志/可捕获
  * B：流式内存 < 10MB；数据吞吐达标
  * C：百万事实/秒；规则规划正确性
  * D：类型推断时间/错误可读性
  * E：效应触发开销；续延正确恢复
  * F：无 STW；编译期捕获资源错误

== 10. 参考资料与下一步

=== 资料
- Lua 5.x、Wren、Janet 源码（小型 VM 的黄金标准）
- Crafting Interpreters（从零到解释器/字节码）
- Engineering a Compiler / Modern Compiler Implementation（IR/优化）
- The Garbage Collection Handbook（GC 设计权衡）
- LuaJIT：DynASM 与 tracing 论文/博客
- TCC / QuickJS 源码（Bellard 风格的“极简而强”）

=== 下一步（行动清单）
1. 今天：确定主目标与非目标；项目骨架与目录搭好；起步即写“慢速模型执行器”
2. 本周：解析/AST 通关；最小 VM 跑起；引入差分与 fuzz harness
3. 本月：对象/内存落地；FFI 定签名规范；profiler 能出第一张图
4. 季度：方向特定能力完整；文档/示例/基准齐备；对外发布 MVP
