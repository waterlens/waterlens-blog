= xref:.[知识点回顾]
:showtitle:
:lang: zh-hans
:stem: latexmath

== 哈希

=== 顺序无关的双射哈希

当哈希值与顺序无关，序列 stem:[[a,b,c\]] 和 stem:[[c,a,b\]] 被认为是相同的输入。它们的本质区别在于元素的种类和计数，正是多重集的定义。
如果元素类型是有限的（例如 K 种类型），那么任何序列都可以唯一地表示为一个长度为 K 的计数向量。


将**计数向量** stem:[\mathbf{C}] 映射到一个唯一的整数，需要确定每个计数 stem:[c_i] 的最大可能值 stem:[M_i]（例如序列的最大长度 stem:[N]）。

假设：
* stem:[$c_{i, \text{max}}$] 是元素 stem:[e_i] 可能的最大计数（例如，序列的最大长度 stem:[N]）。
* 哈希值 stem:[H] 是一个大的整数。

[stem]
++++
H(\mathbf{C}) = \sum_{i=1}^{K} \left( c_i \cdot \prod_{j=1}^{i-1} (c_{j, \text{max}} + 1) \right)
++++

1. 双射性保证：只要所有 stem:[c_i \le c_{i, \text{max}}]，这个映射就是严格的**一一对应关系**，即双射。
2. 哈希值大小：哈希值 stem:[H] 的最大值会非常大。如果 stem:[K=10] 种元素，最大序列长度 stem:[N=10]，哈希值 stem:[H] 最大可能达到 stem:[(10+1)^{10} \approx 2.6 \times 10^{10}]。您需要足够大的整数类型（如 64 位或 128 位）来存储 stem:[H]。

== BFS

=== 可获取层号的 BFS

要点：正常 BFS 无法区分当前是在处理哪一层的元素；在修改版 BFS 中，
我们通过保证队列中的元素总是属于同一层这一不变量来解决这个问题。
我们可以一次性处理同一层的所有节点，并将下一层的所有后代加入队列中。
只需要获取队列初始大小 n 并在一轮中恰好处理 n 个节点即可保证这一点。
正确性可以通过数学归纳法获得。
