= xref:.[今天我学到了] : 记录零散知识的页面
:partition:
:showtitle:
:lang: zh-hans
:stem: latexmath

不定时更新，记录我在浏览网页、阅读论文、逛社媒时看到的细碎知识和技巧。

使用倒序方式记录。

[#date-20240929]
== <<date-20240929, 2024 年 9 月 29 日>>

[discrete]
=== Cyclone: 基于区域的内存管理

现如今，Rust 已经变成了一门备受欢迎的编程语言，在它诸多设计中，允许对生命周期的标注与推导可以说是颇具特色、让人又爱又恨的特性。追溯到学术研究上，那就不能不提 2002 年发表的 https://dl.acm.org/doi/10.1145/512529.512563[Region-Based Memory Management in Cyclone]。这篇出版物描述了作者们在 Cyclone（一个基于 C 语言的 Safe-C 方言）中引入和实现的基于区域的内存管理系统，在之后 Rust 的开发发展有着深远的意义。

在文章中，作者基于之前关于区域内存管理的工作，额外做出了以下贡献：

* 使用后进先出原则，在不同区域间形成一个 outlives 关系，这也是一个子类型关系，从而便利了很多情况下对区域中指针的使用。
* 通过 regions_of 运算符减少了效果变量的使用。
* 为函数推导出默认的效果标注，减轻显式标注的负担。
* 和存在类型相集成。

Cyclone 将内存分为众多的区域，其中一个是特殊的堆区域，具有无限长的生命周期。在 Cyclone 中可以使用 malloc 进行分配（尽管并不能释放。作者推荐了 Boehm GC 用于这个区域的自动垃圾回收）。然后是栈区域，对应着 C 中的局部块。函数参数和局部变量都位于这一区域内。最后是动态区域，具有词法作用域范围的生命周期，并允许在其中进行无限制的内存分配。动态区域需要使用 `region r {s}` 式的语法显式创建。为了从该区域分配一块内存，需要使用用 `rnew(r) 3` 。

Rust 中有类似但不完全对应的构造。 （据我目测估计）Cyclone 的堆和 Rust 的一般堆上对象还是挺不一样的，Cyclone 的堆对象相当于具有 `'static` 的生命周期，而 Rust 的 Box 所指向的内存块的生命周期则是和 Box 对象本身的生命周期相关联。如果 Box 对象的生命周期结束，那么它指向的内存块的生命周期也将很快结束。为了实现 Cyclone 类似的生命周期，要使用 `Box::leak` 显式泄漏该内存块。栈区域，完全一致，没啥好说的。最后是动态区域，这里 Rust 其实并没有像 Cyclone 一样，将内存分配功能实现为区域的一项基本功能。当然，配合 Rust 强大的生态系统，你可以使用任意一个 arena 库，创建一个 arena，并在对应的区域中获得具有相应生命周期的内存块，并在区域结束后自动释放。

Cyclone 的区域类型系统有着如下的设定：

* 区域标注：Cyclone 里的所有指针都关联着一个区域。如 `int*` stem:[\rho] 就表示一个指向 stem:[\rho] 区域的整型指针。标记为 stem:[L] 的块 (`L: {int x = 0; s}`) 具有名称 stem:[\rho_L]，对应着该块创建的块区域。而语句 `region r {s}` 则定义了名为 stem:[\rho_r] 的区域。*区域名字的作用范围对应着区域的生命周期*。在动态区域里用用 `rnew` 创建的指针和在堆区域里取引用获得的指针都将被关联对应的区域。
* 阻止悬垂引用：当指针被解引用时，类型系统可以确保这个指针关联的区域在此刻是存活的，否则就会产生类型错误。
* 区域多态：允许在函数签名上使用抽象区域参数。
* 多态递归：可以用不同的区域名去实例化递归函数中的区域参数（本人注：从类型系统的角度来说，这点似乎不值一提？）
* 类型定义中的区域参数：允许定义类型时其中包含的指针由区域名参数化

为了让以上设计变得实用，必须引入区域间的子类型关系。因此，Cyclone 规定，如果区域 stem:[\rho_1] outlives stem:[\rho_2] ，则允许在任何能使用 `int*r2` 的地方使用 `int*r1`。Cyclone 会自动进行这种 coercion。

Cyclone 额外地追踪函数产生的效果。这一做法的动机是需要避免一个具有较短或者说局部生命周期的指针，通过隐藏在存在类型、闭包（虽然 Cyclone 没有直接支持闭包，但可以用存在类型模拟）中，逃逸至更外层的区域中并被使用。因此，在每个控制流点，Cyclone 都追踪所有存活区域名称的子集。这个集合被称作 Capability。为了允许解引用指针，必须确保指针关联的类型位于 Capability 中。类似地，为了允许函数调用，Cyclone 确保函数可能访问的区域都必须是存活的。为此，Cyclone 要求在函数上标注效果，记录函数可能会使用的区域集。

和之前工作不同，Cyclone 会从函数原型（而无论函数体是什么）为函数推导出一个默认的效果。工作原理是收集所有原型中提到的区域名或者隐式产生的区域参数。当然用户也可以通过手动标注覆盖这个默认推导的结果。

另外一个不同是，Cyclone 并不使用效果变量。对于需要类型变量的地方，使用一个内置的 `regions_of` 类型运算符代替。（本人注：是好设计吗？Rust 是如何规避的？）

例子：

[source, c++]
----
struct Set<a, r, e> {
  list_t<a, r> elts;
  int (*cmp)(a, a; e);
}
----

这里的 `e` 就是一个效果变量，然而 Cyclone 并不支持。用 `regions_of` 运算符，可以改写为：

[source, c++]
----
struct Set<a, r> {
  list_t<a, r> elts;
  int (*cmp)(a, a; regions_of(e));
}
----
