= xref:.[使用 SIMD 指令批量检测字节位于集合中的字节]: 与一种系统化查找表分解法

在进行文本处理时，判断某些字节是否属于特定集合是一项 _基础_ 操作。
对于标量实现而言，针对不同大小和特性的字节集合，判断一个字节是否存在于其中通常采用分支判断、位图或查找表等方法。
利用 SIMD 指令对这一操作进行批量处理，可以在不显著增加单次操作延迟的情况下，大幅提升吞吐量，实现远超标量实现的性能。这种批量化的处理技术又被称作 _向量化分类_。

向量化分类并非新事物：在我受到
https://lemire.me/blog/2023/09/04/locating-identifiers-quickly-arm-neon-edition/[Lemire 相关工作] 启发、自己思考出一种查找表计算方法、并决定写点相关的东西后，
我又发现了 http://0x80.pl/notesen/2018-10-18-simd-byte-lookup.html[另一篇相关的文章]，几乎完整地介绍了向量化分类的各种场景和对应的实现（包括我将要介绍的）。
幸运的是，这篇文章给出的“特例情况”的条件过于苛刻，因此我还能在本文中唠叨一些新东西。

本文将使用 ARM64 指令集中的 Neon 向量指令进行叙述。
不过，大部分内容也适用于支持 SSE2 + SSSE3 指令集的 x86-64 架构。

== 两次查找法

== 如何计算出分解后的查找表？

== 可以使用单次查找法的特例

