= xref:.[随记]: （二）
:partition:
:showtitle:
:lang: zh-hans
:stem: latexmath

== 你对 Compiler/PL 的兴趣变化了吗？

不然。直到现在我最爱的仍然是编译器和编程语言方向，然而不得不感叹，
伴随着 CS 领域持续的人才流入，即便是在细分方向上，仍然充斥着激烈的竞争。
这个时候，我会考虑以下两个问题：

1. 我能否在这种竞争中存活下来？
2. 我能否在竞争中保持对此领域的深入？

对于第一个问题来说，我的答案是能也不能。
从最细分角度 (也就是对泛 Compiler/PL 方向的进一步细分) 来看，
我占据的生态位是非常独特的：懂点 PLT, 懂点编译器，懂点体系结构。
这相当于跨越了完整的编程语言设计 + 编译器开发 + 性能向各环节，
因此在这一类别上直接与我竞争的人并不多。

然而，这一生态位是否是当下所需求的？显然不。
伴随着 AI 狂潮，供需关系就是可以用电力消耗来
衡量的算力和 AI 吃也吃不够的互联/存储/算力需求间的关系。
在这一视角下，编程语言其本身扮演的角色的地位正在下滑。
如果人们需要极致的性能，基于有限的硬件算力，
那他们会毫不犹豫的雇佣劳动力在最底层实现他们所需的各种算子；
如果人们需要抽象，那则会直接诉诸于 Python 等胶水语言或者上层的 DSL。
这两者都并非尔等所能轻易触及：本质上他们都是 HPC/AI 交叉需求而非 PL 需求，
因此 PL 知识并无增益，而未涉及调度的基础 Compiler 知识几乎毫无用处 (竞争对手几乎都有)。
在这种情形下，对于想要投身于 MLSys 和 Compiler 交叉的那一部分人来说，
学习事实上的成功编译框架如 LLVM/MLIR，
然后深入可被纳入 HPC 范畴的计算优化，才可谓唯一的正道。

在这种情况下，我将处在一个陌生的环境下去和从一开始就专注于此路线的人进行竞争，
而这是很困难的，并且会浪费自己已经点上的技能点。这就是所谓“不能”。

可以见得，上述世界远非 PL 人的天堂，那么在何种改变下，我们可以预见更有利的未来呢？

- LLM 达到了其顶峰以至于不能够靠提升算力来继续提高 LLM 表现。
- 硬件算力充分冗余导致人们不必压榨出每一份性能。

这两点都不是短期内可以预见的。

对于第二个问题，我的看法是：很难。
“良禽择木而栖”，在当前中国作为追赶者的背景下，
大多数相关工作仍停留在模仿与改进的阶段。
而模仿与改进，不能说没有其意义，但对人的培养作用是相对较弱的，
反而容易使得让人陷入细节，对特定框架过拟合。
即便是那些颇有新意的项目，
也可能由于没有资金支持或者用户群体过小而无法继续发展。
不论何种情况，这对于个人的深入发展都是不利的。


== 附录：未完工的开发项目

=== mocc

一款基于 tinycc 思路的 C21 编译器，尝试使用 SIMD 技术加速词法分析，尽量实现单趟编译，但由于寄存器分配的问题，可能需要引入中间 IR。

目前进度：前端功能支持。

=== qxq

定位为编程语言编译器综合实验场，尽管最开始使用的是 FP 风格语法并完成了模式匹配器，
但现在目标已经转向无类型语言实现，进而转变为兼具的 JIT 编译器和字节码解释器实验场。

目前进度：代码生成支持

=== regalloc-zoo

用于实验不同寄存器分配算法。为了抽象不同的 ISA 设计了一套专注于描述寄存器读写关系的指令集。
遇到了源汇编转换指令集的困难。

=== wlisp

另一个 lisp 实现。

=== quickaml

原 JIT 技术和解释器技术实验场；现已并入 qxq。

=== tuno

原解释器技术实验场；现已并入 qxq。

== 附录：感兴趣做贡献的项目

=== cranelift

以下记录由 Gemini 生成：

根据会议记录，以下是一些具体且有价值的贡献方向：

1. 为后端添加或完善指令降低 (Instruction Lowering)
    * 描述：将 Cranelift IR 指令转换为特定机器指令的过程。虽然 x64 的 ISLE 迁移已完成，但其他架构（aarch64, s390x,
        riscv64）仍有许多工作可做，特别是 SIMD 和不常用的指令。
    * 切入点：
        - 为 riscv64 后端贡献 SIMD（Vector 扩展）指令的 ISLE 实现。
        - 为 s390x 后端实现对 z17 新指令（如 128 位整数运算）的支持。
        - 实现缺失的 i128 运算（如转换到浮点数）的 libcall 或 ISLE 降低规则。

2. 中端优化规则 (Egraph-based Optimizations)
    * 描述：新的 egraph 优化框架允许通过重写规则来改进代码。社区可以贡献新的规则来提升代码质量。
    * 切入点：
        - 参考 Souper 等工具的输出，或经典的编译器优化理论，为 prelude_opt.isle 添加新的优化规则。
        - 实现对分支指令的优化，例如常量折叠（branch-if-constant）。
        - 为宽整数（如 i128）的运算（如乘法）添加更高效的重写规则。

3. Winch 基线编译器
    * 描述：Winch 是一个追求快速编译的编译器，目前核心功能已完成，但需要支持更多 Wasm 特性。
    * 切入点：
        - 为 Winch 的 x64 或 aarch64 后端实现 SIMD 指令支持。
        - 帮助修复模糊测试发现的 bug，使其完全符合 Wasm 核心规范。

4. 测试与模糊测试 (Fuzzing & Testing)
    * 描述：增强测试覆盖和模糊测试能力对于保证编译器正确性至关重要。
    * 切入点：
        - 修复在 GitHub issue 中标记为 fuzz-bug 的错误。
        - 改进 cranelift-fuzzgen，使其能生成更复杂或更有针对性的测试用例（例如，专门测试边界条件的内存访问）。
        - 为 ISLE 指令选择规则添加覆盖率跟踪，以指导模糊测试。

5. 新汇编器与 ISA 扩展 (New Assembler & ISA Extensions)
    * 描述：x64 后端正在迁移到一个新的、由 DSL 驱动的汇编器。这是一个庞大的工程，需要大量帮助。
    * 切入点：
        - 帮助将剩余的 x64 指令（如条件跳转、CMOVE 等）迁移到新的汇编器框架。
        - 为新汇编器添加对 Intel APX 或 AVX10 扩展的支持。

6. 形式化验证 (Formal Verification)
    * 描述：VeriISLE 项目旨在形式化验证 ISLE 规则的正确性。这是一个更具挑战性的领域，适合有相关背景的贡献者。
    * 切入点：
        - 为 aarch64 或 x86 的浮点和向量指令添加 SAIL 形式化规约。
        - 帮助将 VeriISLE 的注解语言和解析器集成到 Cranelift 主项目中。
